\chapter{RMI mit Concurrency Control}

Führen mehere Clients Methoden auf diesen Objekte auf dem Server aus,
kann es zu sogenannten Lost Update Fehlern kommen. Dieser Fehler  und eine Lösung wird im Abschnitt \ref{sec:concurrency-control}
genauer beschrieben. 

Um die Funktionalität der Lösung zu überprüfen, wurde ein
vereinfachtes RMI System implementiert. Zusätzlich zur
RMI-Funktionalität ent\-hält dies\-es System einen Mechanismus um das Lost
Update Problem zu verhindern. Die Implementation des RMI Systems und
die der Concurrency Control werden in den Abschnitten
\ref{sec:impl-des-eigen} und \ref{sec:conc-contr-impl} erklärt.

Die Dauer, die Methodenaufrufe in diesem RMI System benötigen, werden
später mit einem zweiten RMI-System, welches Objectcaching einsetzt
verglichen. Auf diese Weise wird ersichtlich, welchen
Performancegewinn Objectcaching bringt.


\section{Concurrency control}
\label{sec:concurrency-control}
Werden die Objekte auf dem Server von mehreren Clients verändert, kann
es zum sogenannten Lost Update-Problem kommen. Angenommen zwei
Clients, Client $T$ und Client $U$, wollen den Kontostand von Konto
$A$ um 200 erhöhen. Wenn der Kontostand vor der Änderung 1000 beträgt,
muss der Kontostand nach Abschluss der beiden Transaktionen 1400
betragen. Konto $A$ wird im System mit einem Account-Objekt
repräsentiert. Account bietet folgendes Interface.

\lstset{language=Java}
\begin{lstlisting}
interface Account{
  int getBalance();
  void setBalance(double balance);
}
\end{lstlisting}

Möchte man den Kontostand um 200 erhöhen, liest man mit \newline
\verb|getBalance()| zuerst den akutellen Kontostand und addiert zu
diesem 200 dazu und setzt den neuen Kontostand mit
\verb|setBalance()|. Beide Operationen kann man zu einer Transaktion
zusammenfassen. Solange die Transaktionen sequenziel ablaufen, bleibt die
Konsistenz erhalten. Laufen die Transaktionen auf dem Server
gleichzeitig ab, können Inkonsistenzen auftreten. Lesen Client $T$ und
Client $U$ den Kontostand nacheinander und addieren zum gelesenen Wert
200 um das Resultat mit \verb|setBalance()| zu speichern, beträgt der
Kontostand nach Abschluss beider Transaktionen 1200 statt 1400. Der
Ablauf, der zum Lost Update Fehler führt, wird in Abbildung
\ref{fig:lostupdate} illustriert.

\begin{figure}[h]
  \centering

\begin{tabular}{l | l}
  \textbf{Client $T$} & \textbf{Client $U$} \\ \hline
balance = b.getBalance(); &  \\
 & balance=b.getBalance();  \\
b.setBalance(balance + 200) & \\
& b.setBalance(balance + 200);  \\ \hline
\end{tabular}
    
  \caption{Das Lost Update Problem}
  \label{fig:lostupdate}
\end{figure}

\subsection{Optimistic Concurrency}
\label{sec:optim-conc}

Das System soll Lost-Updates verhindern, indem es das Verfahren
Optimistic Concurrency \cite{wiki:optimistic-concurrency} einsetzt. Clients
können jederzeit \verb|setBalance()| aufrufen. Hat der Datensatz seit
dem letzen Lesezugriff dieses Clients geändert, wird die Methode
abgebrochen und der Client wird benachrichtigt. Er muss die Daten
selbständig mit \verb|getBalance()| aktualisieren und kann es dann
nochmals propieren.

\section{Implementierung des RMI Systems}
\label{sec:impl-des-eigen}

Das RMI-System wurde als Middleware implementiert. Die Middleware soll es
ermöglichen, dass Objekte in unterschiedlichen Prozessen miteinander kommunizieren können. Clientsysteme können mit Objekte arbeiten, die\-
nicht in der selben Virtual Machine leben, sondern auf einem Server. Sie bietet ein Programmiermodel
und macht den Nachrichtenaustausch zwischen den Prozessen
transparent. Die RMI-System nutzt ein ein Request-Reply Protocol \cite{coulouris88}.

\subsection{Clientimplementation}
\label{sec:clientimplementation}

Die Clients arbeiten mit dem Interface Account. Dieses Interface wird
von der Klasse AccountStub implementiert. Der Stub macht aus den
Methodenaufrufen
\verb|getBalance()|und \verb|setBalance()| ein Objekt des Typs
MethodCall. Methodcall ist ein Data Transfer Object. Es enthält
Informationen darüber, welche Methoden aufgerufen werden soll, auf
welchem Objekt die Methoden aufgerufen werden soll und mit welchen
Argumenten die Methode aufrufen wird. Nachdem der Methodenauruf dem
Netzwerkstream übergeben wurde, wartet der Client bis er eine Antwort
auf dem selben Stream erhält. Die Antwort wird mit einem
ReturnValue-Objekt übertragen.

Objekte der Klasse MethodCall und ReturnValue müssen serialisiert
da\-mit sie über einen TCP Stream zwischen Client und Server übertragen
werden können. Die Java Platform bietet dafür die Java Serialization
API an. Objekte die serialisiert werden mit dem Serializable Interface
markiert und mit einem ObjectOutputStream-Objekt serialisiert. Zu
serialisierende Objekte können einfach der Methode
\verb|writeObject(Object object)| übergeben werden.

Ruft der Client eine Methode auf einem Account-Objekt auf, muss er dem
Server mitteilen, auf welchem Objekt die Methode aufgerufen werden
soll. Dafür teilt er dem Server die Objekt-ID im MethodCall-Objekt
mit. Diese Objekt-ID müssen in den Stubs auf Clientseite bei
Methodenaufruf bekannt sein und sie müssen mit den Objekt-ID's auf dem
Server übereinstimmen. Der Client kann Account-Objekte beim Server
anfordern. Das Interface AccountService bietet dafür die Methode
\verb|getAllAccounts()| an. AccountServiceStub
sendet bei Aufruf von \verb|getAllAccounts()|
einen entsprechenden MethodCall an den Server. Dieser MethodCall
enthält keine Objekt-ID. Er returniert immer alle Account-Objekte des
Servers unabhängig davon welches AccountService-Objekt die Methode
aufgerufen hat. Das ReturnValue des Servers enthält eine ArrayList von
Objekt-ID's. Aus diesen ID's werden die AccountStubs auf dem Client generiert.

\subsection{Serverimplementation}
\label{sec:serverimplementation}

Der Server hört akzeptiert eingehende TCP-Verbindungen und liest aus
dem Stream MethodCall-Objekte, sobald welche vom Client gesendet
werden. Der TCP-Stream wird erst geschlossen, wenn der Client ein EOF
sendet.

Für jede Klasse, die RMI-Methoden anbietet, hat der Server ein
zuge\-hö\-ri\-ges Skeletonobjekt. Für die Methodenaufrufe
der Klasse Account ist ein Objekt vom Typ
AccountSkeleton zuständig. Das Skeletonobjekt hat eine HashMap. Die
HashMap enthält alle Account-Objekte des Systems. Die Objekt-ID's
werden als Key's der HashMap eingesetzt. Der AccountSkeleton ist damit
in der Lage ein MethodCall-Objekt, das ein Client versendet hat, an
das richtige Objekt weiterzuleiten. 

Die Skeletonklasse setzt Java Reflection ein um Methoden auf den
Objekten aufzurufen. Das MethodCall Objekt enthält ein
Method-Objekt. Method stellt eine Methode \verb|Object invoke(Object obj, Object[] args)|\- zur\- Ver\-füg\-ung. Das Objekt auf dem die Methode
ausgeführt hat, beschafft sich der Skeleton aus der HashMap. Die
Argumente werden im MethodCall Objekt übermittelt. Der Rückgabewert
wird in ein ReturnValue-Objekt gepackt und an den Client zurückgesendet.

\subsubsection{Schnittstelle zum Framework}
\label{sec:schn-zum-fram}

Für jeden Client muss der Server ein Streamobjekt erstellen. Die
Method\-Call-Objekte aus dem Streamobjekt müssen an das selbe
AccountSkeleton-Objekt weitergeleitet werden. Streamobjekte speichern
und Methodenauf\-rufe an das richtige Skeleton weiterzuleiten ist
Aufgabe der Clienthandler. Damit diese Clienthandler-Objekte mit den
richtigen Skeleton-Objekte initialisiert werden, bietet das System
eine zentrale ServerSystem-Klasse. Das Framework erzeugt eine Instanz
der ServerSystem-Klasse. Wenn sich Client mit dem Server verbindet,
fordert das Framework von diese Serversystem\-instanz einen
Clienthandler an. Dieser wird mit den richtigen SkeletonObjekte
initialisiert. Das Framework übergibt dem Clienthandler die Input- und OutputStreamobjekte.

\section{Concurrency Control Implementierung }
\label{sec:conc-contr-impl}

Das System soll Lost-Updates verhindern, indem es bei Schreizugriffen
feststellt, ob die Daten zwischenzeitlich verändert wurden. Dazu
versioniert der Server die Objekte, deren Methoden auf entfernten
Clients aufgerufen werden können. Die Versionen werden in der HashMap
$W$ gespeichert. Die HashMap $W$ verwendet als Key die ID der Objekte
und als Value die Version. Bei jedem Schreibzugriff, das heisst bei
einem \verb|setBalance()|, der ohne Konflikt ausgeführt wird, wird die
Version des Objektes inkrementiert. Zusätzlich merkt sich der Server
für jeden Client und für jedes Objekt, auf welcher Version des
Objektes ein Lesezugriff (\verb|getBalance()| stattgefunden hat. Dafür
wird eine zweite HashMap $R$ verwendet. In der HashMap $R$ wird als Key
ein String verwendet, der sich aus der IP-Adresse und der
Objekt-ID des Methodenaufrufs zusammensetzt. Als Value speichert die HashMap $R$ die Version ab.
Ruft ein Client
\verb|getBalance()| auf, holt der Server die aktuelle Version aus dem
der HashMap $W$ und speichert sie in mit der entsprechenden IP und
Objekt-ID in der HashMap $R$ ab.

Mit den beiden HashMaps $W$ und $R$, weiss der Server welches die
aktuellste Version eines Objektes und mit welcher Version jeder Client
arbeitet. Ruft ein Client \verb|setBalance()| prüft der Server, ob die
Version des Clients aus der HashMap $R$ tiefer ist als die aktuelle
Version aus der HashMap $W$. Ist dies der Fall wird der Methodenaufruf
abgebrochen und der Client erhält eine Nachricht, dass die Methode
nicht ausgeführt werden konnte.