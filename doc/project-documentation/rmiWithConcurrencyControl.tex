\chapter{RMI mit Concorrency Control}

Um zu zeigen, welche Auswirkungen Objectcaching auf ein verteiltes
System hat, wurde ein Vergleichssystem ohne Cache geschaffen. Das
RMIonly System ist eine Middleware. Sie bietet ein Programmiermodel
und macht den Nachrichtenaustausch zwischen den Prozessen transparent.

\section{Implementierung des RMI Systems}
\label{sec:impl-des-eigen}

Die RMIonly System nutzt ein ein Request-Reply Protocol
\cite{coulouris88}.

\subsection{Clientimplementation}
\label{sec:clientimplementation}

Die Clients arbeiten mit dem Interface Account. Dieses Interface wird
von der Klasse AccountStub implementiert. Der Stub macht aus den
Methodenaufrufen
\verb|getBalance()|und \verb|setBalance()| ein Objekt des Typs
MethodCall. Methodcall ist ein Data Transfer Object. Es enthält
Informationen darüber, welche Methoden aufgerufen werden soll, auf
welchem Objekt die Methoden aufgerufen werden soll und mit welchen
Argumenten die Methode aufrufen wird. Nachdem der Methodenauruf dem
Netzwerkstream übergeben wurde, wartet der Client bis er eine Antwort
auf dem selben Stream erhält. Die Antwort wird mit einem
ReturnValue-Objekt übertragen.

Objekte der Klasse MethodCall und ReturnValue müssen serialisiert
da\-mit sie über einen TCP Stream zwischen Client und Server übertragen
werden können. Die Java Platform bietet dafür die Java Serialization
API an. Objekte die serialisiert werden mit dem Serializable Interface
markiert und mit einem ObjectOutputStream-Objekt serialisiert. Zu
serialisierende Objekte können einfach der Methode
\verb|writeObject(Object object)| übergeben werden.

Ruft der Client eine Methode auf einem Account-Objekt auf, muss er dem
Server mitteilen, auf welchem Objekt die Methode aufgerufen werden
soll. Dafür teilt er dem Server die Objekt-ID im MethodCall-Objekt
mit. Diese Objekt-ID müssen in den Stubs auf Clientseite bei
Methodenaufruf bekannt sein und sie müssen mit den Objekt-ID's auf dem
Server übereinstimmen. Der Client kann Account-Objekte beim Server
anfordern. Das Interface AccountService bietet dafür die Methode
\verb|getAllAccounts()| an. AccountServiceStub
sendet bei Aufruf von \verb|getAllAccounts()|
einen entsprechenden MethodCall an den Server. Dieser MethodCall
enthält keine Objekt-ID. Er returniert immer alle Account-Objekte des
Servers unabhängig davon welches AccountService-Objekt die Methode
aufgerufen hat. Das ReturnValue des Servers enthält eine ArrayList von
Objekt-ID's. Aus diesen ID's werden die AccountStubs auf dem Client generiert.

\subsection{Serverimplementation}
\label{sec:serverimplementation}

Der Server hört akzeptiert eingehende TCP-Verbindungen und liest aus
dem Stream MethodCall-Objekte, sobald welche vom Client gesendet
werden. Der TCP-Stream wird erst geschlossen, wenn der Client ein EOF
sendet.

Für jede Klasse, die RMI-Methoden anbietet, hat der Server ein
zuge\-hö\-ri\-ges Skeletonobjekt. Für die Methodenaufrufe
der Klasse Account ist ein Objekt vom Typ
AccountSkeleton zuständig. Das Skeletonobjekt hat eine HashMap. Die
HashMap enthält alle Account-Objekte des Systems. Die Objekt-ID's
werden als Key's der HashMap eingesetzt. Der AccountSkeleton ist damit
in der Lage ein MethodCall-Objekt, das ein Client versendet hat, an
das richtige Objekt weiterzuleiten. 

Die Skeletonklasse setzt Java Reflection ein um Methoden auf den
Objekten aufzurufen. Das MethodCall Objekt enthält ein
Method-Objekt. Method stellt eine Methode \verb|Object invoke(Object obj, Object[] args)|\- zur\- Ver\-füg\-ung. Das Objekt auf dem die Methode
ausgeführt hat, beschafft sich der Skeleton aus der HashMap. Die
Argumente werden im MethodCall Objekt übermittelt. Der Rückgabewert
wird in ein ReturnValue-Objekt gepackt und an den Client zurückgesendet.

\subsubsection{Schnittstelle zum Framework}
\label{sec:schn-zum-fram}

Für jeden Client muss der Server ein Streamobjekt erstellen. Die
Method\-Call-Objekte aus dem Streamobjekt müssen an das selbe
AccountSkeleton-Objekt weitergeleitet werden. Streamobjekte speichern
und Methodenauf\-rufe an das richtige Skeleton weiterzuleiten ist
Aufgabe der Clienthandler. Damit diese Clienthandler-Objekte mit den
richtigen Skeleton-Objekte initialisiert werden, bietet das System
eine zentrale ServerSystem-Klasse. Das Framework erzeugt eine Instanz
der ServerSystem-Klasse. Wenn sich Client mit dem Server verbindet,
fordert das Framework von diese Serversystem\-instanz einen
Clienthandler an. Dieser wird mit den richtigen SkeletonObjekte
initialisiert. Das Framework übergibt dem Clienthandler die Input- und OutputStreamobjekte.

\section{Concurrency Control Implementierung }
\label{sec:conc-contr-impl}



\subsection{Konzept}
\label{sec:konzept}

Ziel des Konzept, ist das  
Der Server verwaltet eine HashMap H1. H1 hat verwendet als Key/Value Pair Object/Version. 



